import { setMaxListeners } from 'node:events';
import { logger } from '@libp2p/logger';
import { anySignal } from 'any-signal';
import { Device } from './device.js';
const log = logger('nat-port-mapper:upnp');
export class UPNPClient {
    closed;
    discoverGateway;
    shutdownController;
    static createClient(discoverGateway) {
        return new UPNPClient(discoverGateway);
    }
    constructor(discoverGateway) {
        this.discoverGateway = discoverGateway;
        this.closed = false;
        // used to terminate network operations on shutdown
        this.shutdownController = new AbortController();
        setMaxListeners(Infinity, this.shutdownController.signal);
    }
    async map(localPort, options) {
        if (this.closed) {
            throw new Error('client is closed');
        }
        const signal = anySignal([this.shutdownController.signal, options.signal]);
        setMaxListeners(Infinity, signal);
        const gateway = await this.findGateway();
        const description = options.description ?? 'node:nat:upnp';
        const protocol = options.protocol === 'TCP' ? options.protocol : 'UDP';
        let ttl = 60 * 30;
        if (typeof options.ttl === 'number') {
            ttl = options.ttl;
        }
        if (typeof options.ttl === 'string' && !isNaN(options.ttl)) {
            ttl = Number(options.ttl);
        }
        log('mapping local port %d to public port %d', localPort, options.publicPort);
        const response = await gateway.run('AddAnyPortMapping', [
            ['NewRemoteHost', options.publicHost ?? ''],
            ['NewExternalPort', options.publicPort],
            ['NewProtocol', protocol],
            ['NewInternalPort', localPort],
            ['NewInternalClient', options.localAddress],
            ['NewEnabled', 1],
            ['NewPortMappingDescription', description],
            ['NewLeaseDuration', ttl]
        ], signal);
        const key = this.findNamespacedKey('AddAnyPortMappingResponse', response);
        return Number(response[key].NewReservedPort);
    }
    async unmap(localPort, options) {
        if (this.closed) {
            throw new Error('client is closed');
        }
        const signal = anySignal([this.shutdownController.signal, options.signal]);
        setMaxListeners(Infinity, signal);
        const gateway = await this.findGateway({
            ...options,
            signal
        });
        await gateway.run('DeletePortMapping', [
            ['NewRemoteHost', options.publicHost],
            ['NewExternalPort', options.publicPort],
            ['NewProtocol', options.protocol]
        ], signal);
    }
    async externalIp(options) {
        if (this.closed) {
            throw new Error('client is closed');
        }
        log('discover external IP address');
        const gateway = await this.findGateway(options);
        const response = await gateway.run('GetExternalIPAddress', [], this.shutdownController.signal);
        const key = this.findNamespacedKey('GetExternalIPAddressResponse', response);
        log('discovered external IP address %s', response[key].NewExternalIPAddress);
        return response[key].NewExternalIPAddress;
    }
    findNamespacedKey(key, data) {
        let ns = null;
        Object.keys(data).some((k) => {
            if (new RegExp(`!/:${key}$/`).test(k)) {
                return false;
            }
            ns = k;
            return true;
        });
        if (ns == null) {
            throw new Error('Incorrect response');
        }
        return ns;
    }
    async findGateway(options) {
        if (this.closed) {
            throw new Error('client is closed');
        }
        const signal = anySignal([this.shutdownController.signal, options?.signal]);
        setMaxListeners(Infinity, signal);
        const discover = this.discoverGateway();
        const service = await discover({
            ...options,
            signal
        });
        if (service != null) {
            return new Device(service);
        }
        throw new Error('could not find gateway');
    }
    async close() {
        this.closed = true;
        this.shutdownController.abort();
    }
}
//# sourceMappingURL=index.js.map