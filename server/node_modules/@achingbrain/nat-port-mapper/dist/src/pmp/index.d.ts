/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
import { EventEmitter } from 'events';
import { type DeferredPromise } from 'p-defer';
import type { DiscoverGateway } from '../discovery/index.js';
import type { Client, InternalMapOptions } from '../types.js';
import type { AbortOptions } from 'abort-error';
import type { RemoteInfo } from 'dgram';
declare const OP_EXTERNAL_IP = 0;
declare const OP_MAP_UDP = 1;
declare const OP_MAP_TCP = 2;
export interface PortMappingOptions {
    type?: 'tcp' | 'udp';
    ttl?: number;
    public?: number;
    private?: number;
    internal?: number;
    external?: number;
}
export declare class PMPClient extends EventEmitter implements Client {
    private readonly socket;
    private queue;
    private connecting;
    private listening;
    private req;
    private reqActive;
    private readonly discoverGateway;
    private gateway?;
    static createClient(discoverGateway: () => DiscoverGateway): PMPClient;
    constructor(discoverGateway: () => DiscoverGateway);
    connect(): void;
    map(localPort: number, opts: InternalMapOptions): Promise<number>;
    unmap(localPort: number, opts: InternalMapOptions): Promise<void>;
    externalIp(options?: AbortOptions): Promise<string>;
    close(options?: AbortOptions): Promise<void>;
    /**
     * Queues a UDP request to be send to the gateway device.
     */
    request(op: typeof OP_EXTERNAL_IP, deferred: DeferredPromise<any>): void;
    request(op: typeof OP_MAP_TCP | typeof OP_MAP_UDP, deferred: DeferredPromise<any>, localPort: number, obj: InternalMapOptions): void;
    /**
     * Processes the next request if the socket is listening.
     */
    _next(): void;
    onListening(): void;
    onMessage(msg: Buffer, rinfo: RemoteInfo): void;
    onClose(): void;
    onError(err: Error): void;
}
export {};
//# sourceMappingURL=index.d.ts.map